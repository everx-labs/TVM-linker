# TVM linker

This repository stores source code for tool called tvm_linker that takes TVM (https://test.ton.org/tvm.pdf) 
assembly source code of TON smart contract, compiles it and links its parts, adds standard selector 
and runtime and stores it into binary TVC file. Also, it can immediately execute smart 
contract by emulating compute phase of TON transaction.

TVM assembly can be generated by one of TONLabs compilers:
- TON solidity compiler (https://github.com/tonlabs/TON-Solidity-Compiler)
- C and C++ compiler for TVM (https://github.com/tonlabs/TON-Compiler)

## Prerequesites

Rust 1.38 or higher, cargo tool


## How to build

	cargo build [--release]

## How to use

The linker has several modes of work:

### 1) Generating ready-to-deploy contract.
    tvm_linker compile [--lib <lib_file>] [--abi-json <abi_file>] [--genkey | --setkey <keyfile>] [-w <workchain_id>] [--debug] <source>

Here `source` is a name of tvm assembly source file, `library` is a runtime library file (can be more than one: `--lib` 
should be supplied for every file).

If contract ABI file presents it is better to use `--abi-json` option to supply contract ABI file. Function ids will be generated according to function signatures in ABI.

Linker generates `address.tvc` file, where `address` is a hash from initial data and code of the contract.

Linker prints contract address in different formats: raw and user-friendly (testnet and mainnet). Define workchain id option `-w` 
to generate proper user-friendly address. -1 is used by default.

To generate a new keypair and put the public key to the contract:

	tvm_linker compile <source> --genkey <key_file>

where `key_file` is a name of the file to store public and private keys. The linker will generate 2 files: `key_file.pub` for public key and `key_file` for private key.

To load existing keypair use:

	tvm_linker compile <source> --setkey <key_file>

### 2) Decoding of boc messages, prepared somewhere else.
To use this method, call

	tvm_linker decode [--tvc] boc-file

If `--tvc` is omitted, `boc-file` is a file with serialized message, otherwise it is a contract `tvc` file.

### 3) Preparing external inbound messages in boc format.

First, generate contract as described in 1). Then use `message` subcommand to create external inbound message in boc format:

	tvm_linker message <contract-address> [--init] [--data] [-w]

	tvm_linker message <contract-address> [--init] --abi-json <abi_file> --abi-method <method_name> --abi-params {json_with_params} [-w]

`contract-address` - the name of the compiled contract file without extension. Contract tvc file should be placed in current directory.

To create `constructor message` with contract's code and data, use `--init` option.

Aditionally, you can add raw body to the message with option `--data':

	tvm_linker message <contract-address> --data XXXX...

Instead of `XXXX...`, specify the necessary message body in hex format. 

Or make a message with ABI call using combination of options:
- `--abi-json <abi_file>` - path to json with contract interface described according to ABI specification,
- `--abi-method <method-name>` - name of the contract method to call,
- `--abi-params {<json-string-with-params>}` - arguments of the method declared in json like this: `{"arg_a": "0x1234", "arg_b": "x12345678"}`.

By default, -1 is used as a workchain id in contract address. To use another one, use `-w` option:

	tvm_linker message -w 0

### 4) Emulating execution of the contract:

Linker can emulate compute phase of blockchain transaction. This is useful for contract debugging.

	tvm_linker test <contract-address> --body XXXX... [--sign key-file] [--trace] [--decode-c6] [--internal value] [-s source-file]

Loads contract from file by contract address `address` and emulates contract call sending external inbound message (by default) with body defined after `--body` parameter to the contract. `XXXX...` is a hex string. 

If `--sign` specified, the body will be signed with the private key from `key-file` file.

Use `--trace` flag to trace VM execution: stack, registers and gas will be printed after each executed VM command.

Use `--decode-c6` to see output actions in user friendly format.

Use `--internal` to send internal message to the contract with defined nanograms in `value`.

ABI body can be generated if `abi-params`, `abi-json` and `abi-method` will be used instead of `--body XXXX...`.

If `--body` is used, contract's public function ids can be encoded by their names using `$...$` syntax:`$name:[0len][type]$`, 
where `name` is a name of public function, `len` - length in chars of the id (if `len` is bigger than `name`'s length in chars than 
zeros will be added at the left side to fit required length), `type` can be `x` or `X` - hexademical integer  in lowercase or uppercase. You have to set `-s source` option when you use $...$ syntax.

Example:

	tvm_linker address test --body 00$main$ -s source //main id will be inserted as decimal string. Dont use this case, just as example
	tvm_linker address test --body 00$main:08X$ -s source
	tvm_linker address test --body 00$main:X$ -s source
	tvm_linker address test --body 00$main:x$ -s source

### More Help
Use `tvm_linker --help` for detailed description about all options, flags and subcommands.

## Input format

As a temporary measure, some LLVM-assembler like input is used.
The source code should consist of functions of different types:

- .selector - contract's entry point. This function should be short.

```
	.selector
	<code here>
```

- .globl - general purpose functions, can be public or private.

```
	.globl	x
	[.public x]
	.type x, @function
	x:
	<code here>
```

- .internal - special functions, which are used only by contract's runtime. There are some wellknown internal functions:

	main_external, main_internal, main_ticktock, main_split, main_merge

## Support

Videos and samples illustrating how to use the tvm_linker will soon appear at https://ton.dev/ and https://www.youtube.com/channel/UC9kJ6DKaxSxk6T3lEGdq-Gg. Stay tuned.