	.internal-alias :main_external,     -1
	.internal-alias :main_internal,     0
	.internal-alias :general_purpose,   1
	.internal-alias :authenticate,      2
	.internal-alias :parse_msg,         3

	.internal-alias :init_fstack,       4
    .internal-alias :term_fstack,       10
	.internal-alias :enter,             5
	.internal-alias :leave,             6
	.internal-alias :load,              7
	.internal-alias :store,             8
	.internal-alias :frameidx,          9

	.internal-alias :load_bp,           11
	.internal-alias :store_bp,          12
	.internal-alias :load_work_slice,  13
	.internal-alias :store_work_slice, 14
    .internal-alias :encode_grams,     15

	.persistent-base 100
	.global-base 1000000

    .selector
    ; s0 - func_id
    ; s1.. - other data
    SETCP0
    ACCEPT
    PUSHREFSLICE        ; dictionary of methods in first reference
    PLDDICT
    OVER
    NEQINT 1
    PUSHCONT {          ; if func_id negative or zero - direct call to method
        PUSHINT 32
        DICTIGETJMP     ; execute method and return
    }
    PUSHCONT {          ; get dictionary with methods
        PUSHINT 32
        DICTIGETREF
        THROWIFNOT 52   ; no dictionary of methods
        PUSHINT 32
        DICTUGETJMP     ; execute method and return
        THROW 51
    }
    IFELSE

    .internal   :authenticate
    ;ref0 must contains auth dictionary
    ;args: 
    ;   s0 - body slice
    ;ret: 
    ;   s0 - body slice (modified: without ref0)
    ;   s1 - sender pubkey: integer
    ;throws exception if signature cell is missing
    ;throws exception if signature is invalid

    PUSHINT 0
    SWAP
    DUP
    SREMPTY         ;body must have reference, if not - throw exception
    THROWIF 40      ;signature cell not found 
    LDREFRTOS       ;detach signature slice
    DUP
    SEMPTY
    PUSHCONT {
        DROP
    }
    IFJMP
    OVER
    HASHSU
    SWAP
    PUSHINT 512
    LDSLICEX
    LDU 256
    DROP
    ;save sender key
    DUP
    POP s5
    ;now check signature
    CHKSIGNU
    THROWIFNOT 40   ;access denied exception
    RET

    .globl  tvm_sender_pubkey
    .type   tvm_sender_pubkey, @function
tvm_sender_pubkey:    
    PUSH c7
    INDEX 2

    .internal   :main_external
    ; s0 - msg body: slice
    ; s1 - msg: cell
    ; s2 - gram balance of msg: int
    ; s3 - gram balance of contract: int

    ;check whether the message body is empty
    DUP
    SDEMPTY
    IFRET       ;return if body is empty: that is an initialization message
    ;TODO: implement better reaction on init messages

    ;call signature checker (can throw exception if signature is invalid)
    CALL $:authenticate$ ;assume that function returns nothing

    ;call msg parser
    PUSH s2     ;push msg cell on top
    CALL $:parse_msg$    ;assume thar parser returns slice - dictionary with msg fields
    ;stack: msg_slice body sender_pubkey
    ROT
    ; Initialize C stack
    CALL $:init_fstack$

    SWAP
    ;parse ABI version (1 byte) and load function id (4 bytes)
    LDU 8       ;load ABI version
    SWAP  
    THROWIF 55  ; only version 0 is supported now
    LDU 32      ;load func id
    DUP
    CALL $:store_work_slice$
    SWAP
    CALL 1      ;public method call
    JMP $:term_fstack$

    .internal   :main_internal
    RET         ;contract ignores internal msgs by default 

    .internal   :parse_msg
    CTOS        ;TODO: use parser from contract_api library


; Functions for C
; 2000000000: BP pointer
    .internal   :load_bp
    PUSHINT 2000000000
    CALL $:load$

    .internal   :store_bp
    PUSHINT 2000000000
    XCHG s0, s1
    CALL $:store$

    .internal   :encode_grams
	;s0 - value: integer (u64)
	;s1 - builder
	DUP
	PUSHCONT {
		DUP
		UBITSIZE    ; bit count used by integer
		PUSHINT 8
		DIVC        ; calculate number of bytes needed for integer
		DUP
		PUSH s3     ; push builder
		STU 4       ; store len (bytes)
		SWAP
		PUSHINT 8
		MUL         ; calculate bits for integer (rounded to byte)
		STUX        ; store value
		NIP
	}
	PUSHCONT {
		DROP
		PUSHINT 0
		STUR 4
	}
	IFELSE

    .internal   :init_fstack
    ;s0 - pubkey
    ; Initialize stack
    ; At initialization: 
    ; 1) C4 contains persistent_data
    ; 1.5) Dict in C4 at persistent_base + 8 contains dictionary of global data
    ; 2) C7 contains tuple with smart_contract_info at first item
    ; 
    ; Result:
    ; 1) C7 contains tuple (smart_contract_info, memory dictionary)

    ;load smart_contract_info tuple and pack to slice
    PUSH c7
    FIRST
    UNPACKFIRST 9   ;unpack tuple
    REVERSE 9, 0
    NEWC
    STU 32      ;magic
    STU 16      ;actions
    STU 16      ;msgs_sent
    STU 32      ;unixtime
    STU 64      ;block_lt
    STU 64      ;trans_lt
    STU 256     ;rand_seed
    SWAP        
    EXPLODE 2   ;unpack remaining_balance tuple
    DROP DROP   ;drop count and other currency cell
    CALL $:encode_grams$
    STSLICECONST 0
    STSLICE     ;store myself:MsgAddressInt
    ENDC
    CTOS
    
    PUSHINT 2000000001
    PUSHINT 108
    PUSH c4                    ; (pubkey sci_slice sci_addr persistent_base+8 persistent-dict-cell )
    CTOS
    PLDDICT
    PUSHINT 64                 ; (pubkey persistent_base+8 persistent-dict addr-width )
    DICTIGET                   ; (pubkey global-dict? flag )
    THROWIFNOT 42              ; (pubkey global-dict )
    PLDDICT                    ; (pubkey global-dict )
    PUSHINT 64
    DICTISET                   ; (pubkey global-dict )
    NEWC STDICT ENDC           ; (pubkey dict_cell )
    PUSH c7 SWAP               ; (pubkey c7 dict_cell )
    TPUSH                      ; (pubkey c7' ) c7=(slice_with_smart_contract_info_ref, dict_cell)
    SWAP                       ; (c7' pubkey)
    TPUSH                      ; as THIRD     
    POP c7

    PUSHINT 1000000000         ; ( new_stack_base_pointer )
    CALL $:store_bp$           ; ( )
    RET

    .internal	:term_fstack
    ; Terminate stack -- copy values back from C7
    ; 
    ; Before termination: 
    ; 1) C7 contains a tuple (smart_contract_info, memory dictionary)
    ; 2) At key -99999 the dictionary contains the ref to smart_contract_info
    ; 
    ; Result:
    ; 1) C7 contains singleton (smart_contract_info);
    ; todo: update
    PUSH c7                    ; ( c7 )
    TPOP                       ; drop global memory dictionary
    DROP
    POP c7                     ; reset c7

    .internal   :enter
    CALL $:load_bp$
    SWAP
    SUB
    CALL $:store_bp$

    .internal   :leave
    CALL $:load_bp$
    ADD
    CALL $:store_bp$

    .internal   :load
    ; ( addr -- value )
    ; If addr < 100000 --- persistent address
    DUP
    PUSHINT 100000
    LESS
    PUSHCONT { PUSH c4 }
    PUSHCONT {
      PUSH c7
      SECOND
    }
    IFELSE

    CTOS
    PLDDICT
    PUSHINT 64
    DICTIGET ; (addr dict key-width -- value-slice flag)

    THROWIFNOT 60
    PUSHINT 257 LDIX 
    ENDS

    .internal   :store
    ; (addr val -- )
    NEWC 
    PUSHINT 257 STIX 
    ENDC
    CTOS     ; (addr val-slice)
    XCHG s0, s1
    ; (val-slice addr)

    DUP          ; (val-slice addr addr)
    PUSHINT 100000
    LESS         ; (val-slice addr persistent?)
    PUSHCONT { 
        PUSH c4
        CTOS     ; (val-slice addr dict-slice)
        PLDDICT  ; (val-slice addr dict)
        PUSHINT 64
        DICTISET ; (val-slice addr dict key-width -- dict')
        NEWC STDICT ENDC
        POP c4
    }
    PUSHCONT {
        PUSH c7
        SECOND
        CTOS     ; (c7 val-slice addr dict-slice)
        PLDDICT  ; (c7 val-slice addr dict)
        PUSHINT 64
        DICTISET ; (c7 val-slice addr dict key-width -- c7 dict')
        NEWC STDICT ENDC
        PUSH c7 SWAP
        SETSECOND
        POP c7
    }
    IFELSE

    .internal   :frameidx
    CALL $:load_bp$
    ;PUSHINT 10 ; arbitrary value
    ADD

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; User-level functions and constants ;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ;
    ; Get builder cell (internal call)
    ; ( -- builder-cell )
    ;
    .internal	:load_work_slice
    PUSHINT 2000000002     ; ( builder-cell-address )
    PUSH c7
    SECOND
    CTOS
    PLDDICT
    PUSHINT 64
    DICTIGET               ; ( addr dict key-width -- work-slice flag )
    THROWIFNOT 60

    ;
    ; Set builder cell (internal call)
    ; ( builder-cell -- )
    ;
    .internal	:store_work_slice
    PUSHINT 2000000002     ; ( cell addr )
    PUSH c7
    SECOND
    CTOS                   ; ( cell addr dict)
    PLDDICT
    PUSHINT 64
    DICTISET               ; ( cell addr dict key-width -- dict' )
    NEWC STDICT ENDC
    PUSH c7 SWAP
    SETSECOND
    POP c7                 ; ( )

    ; smart contract info --- get it from stack
    .globl	tonstdlib_get_smart_contract_info
    .type	tonstdlib_get_smart_contract_info,@function
tonstdlib_get_smart_contract_info:
    PUSHINT 2000000001     ; address of slice with smart_contract_info_ref
    PUSH c7
    SECOND
    CTOS
    PLDDICT
    PUSHINT 64
    DICTIGET               ; ( addr dict key-width -- smart_contract_info_slice flag )
    THROWIFNOT 60          ; ( smart_contract_info_cell )
    JMP $:store_work_slice$

    ;
    ; Initialize work cell
    ; ( -- )
    ;
    .globl	tonstdlib_create_empty_work_slice
    .type	tonstdlib_create_empty_work_slice,@function
tonstdlib_create_empty_work_slice:
    PUSHSLICE x8_         ; create empty slice: ( empty_slice )
    JMP $:store_work_slice$

    ;
    ; Append work cell with an integer:
    ; ( int-value width -- )
    ;
    .globl	tonstdlib_work_slice_store_int
    .type	tonstdlib_work_slice_store_int,@function
tonstdlib_work_slice_store_int:
    CALL $:load_work_slice$    ; ( int-value width work-slice )
    NEWC STSLICE               ; ( uint-value width work-cell-builder )
    SWAP                       ; ( uint-value work-cell-builder width )
    STIX                       ; ( work-cell-builder' )
    ENDC                       ; ( work-cell )
    CTOS                       ; ( work-slice )
    JMP $:store_work_slice$

    ;
    ; Append work cell with an unsigned integer:
    ; ( uint-value width -- )
    ;
    .globl	tonstdlib_work_slice_store_uint
    .type	tonstdlib_work_slice_store_uint,@function
tonstdlib_work_slice_store_uint:
    CALL $:load_work_slice$    ; ( uint-value width work-slice )
    NEWC STSLICE               ; ( uint-value width work-cell-builder )
    SWAP                       ; ( uint-value work-cell-builder width )
    STUX                       ; ( work-cell-builder )
    ENDC                       ; ( work-cell )
    CTOS                       ; ( work-slice )
    JMP $:store_work_slice$

    ;
    ; Load integer from work cell:
    ; ( width -- int-value )
    ;
    .globl	tonstdlib_work_slice_load_int
    .type	tonstdlib_work_slice_load_int,@function
tonstdlib_work_slice_load_int:
    CALL $:load_work_slice$    ; ( width work-slice )
    SWAP                       ; ( work-slice width )
    LDIX                       ; ( int-value work-slice' )
    JMP $:store_work_slice$

    ;
    ; Load unsigned from work cell:
    ; ( width -- uint-value )
    ;
    .globl	tonstdlib_work_slice_load_uint
    .type	tonstdlib_work_slice_load_uint,@function
tonstdlib_work_slice_load_uint:
    CALL $:load_work_slice$    ; ( width work-slice )
    SWAP                       ; ( work-slice width )
    LDUX                       ; ( int-value work-slice' )
    JMP $:store_work_slice$

    ;
    ; Get builder cell 
    ; ( -- builder-cell )
    ;
    .globl	tonstdlib_get_work_slice
    .type	tonstdlib_get_work_slice,@function
tonstdlib_get_work_slice:
    JMP $:load_work_slice$

    ;
    ; Send raw message: takes message from work slice
    ; ( flags -- )
    ;
    .globl	tonstdlib_send_work_slice_as_rawmsg
    .type	tonstdlib_send_work_slice_as_rawmsg,@function
tonstdlib_send_work_slice_as_rawmsg:
    CALL $:load_work_slice$
    NEWC STSLICE ENDC
    SWAP
    SENDRAWMSG

    ;;;;;;;;;;;;;;;;;;;;;
    ; Std library for C ;
    ;;;;;;;;;;;;;;;;;;;;;

    ;
    ;
    ;
	.text
	.file	"memcpy-test.c"
	.globl	memcpy
	.p2align	1
	.type	memcpy,@function
memcpy:                  ; { dst | src | size | - }
    PUSH s2              ; { dst | src | size | dst | - }
    ROLLREV 2            ; { dst | dst | src | size | - }
    PUSHCONT {         ; { dst | dst' | src' | - }
        DUP2             ; { dst | dst' | src' | dst' | src' | - }
        CALL $:load$     ; { dst | dst' | src' | dst' | value | - }
        CALL $:store$    ; { dst | dst' | src' | - }
        
        INC              ; { dst | dst' | src'++ | - }
        SWAP             ; { dst | src' | dst' | - }
        INC              ; { dst | src' | dst'++ | - }
        SWAP             ; { dst | dst' | src' | - }
    }                  ; { dst | dst | src | size | cont | - }
    REPEAT               ; { dst | dst | src | size | cont | - } => { dst | dst | src | - }
    DROP2                ; { dst }
    RET
.Lfunc_end0:
	.size	memcpy, .Lfunc_end0-memcpy


     .globl	memset
     .type	memset,@function
memset:
     ; ( addr value size -- addr )
     ;
     PUSH s2              ; ( addr value size addr )
     XCHG s0,s1           ; ( addr value addr size )
     PUSHCONT {           ; ( addr value addr -- value addr' )
         PUSH s0          ; ( addr value addr' addr' )
         PUSH s2          ; ( addr value addr' addr' value )
         CALL $:store$
         INC              ; ( addr value (addr' = addr' + 1) )
     }
     REPEAT               ; ( addr value addr size cont -- addr value addr' )
     DROP                 ; ( addr value )
     DROP                 ; ( addr )
