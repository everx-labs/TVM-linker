	.internal-alias :main_external,     -1
	.internal-alias :main_internal,     0
	.internal-alias :general_purpose,   1
	.selector
	; s0 - func_id
	; s1.. - other data
	SETCP0
	ACCEPT
	PUSHREFSLICE        ; dictionary of methods in first reference
	PLDDICT
	OVER
	NEQINT 1
	PUSHCONT {          ; if func_id negative or zero - direct call to method
		PUSHINT 32
		PRINTSTR selector_jmp_0
		DICTIGETJMP     ; execute method and return
	}
	PUSHCONT {          ; get dictionary with methods
		PUSHINT 32
        DICTIGETREF
		THROWIFNOT 52   ; no dictionary of methods
		PUSHINT 32
		PRINTSTR selector_jmp
		DICTUGETJMP     ; execute method and return
		THROW 51
	}
	IFELSE


	.internal   :main_external
	PUSHINT $main_external_body$
	CALL 1
	IFRET
	CALL 1 ;public method call


	.internal   :main_internal
	PUSHINT $main_internal_body$
	CALL 1
	IFRET
	CALL 1 ;public method call
	RET

				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				;;; THE CODE BELOW IS GENERATED. DO NOT CHANGE IT!

.globl	get_pubkey
.type	get_pubkey, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: get_pubkey
;; get member pubkey
;; Index of TvmTempData.pubkey
PUSHINT 0
;; tvm_get_tmp_dictionary
PUSH c7
SECOND
CTOS
PLDDICT
PUSHINT 8
DICTUGET
PUSHCONT { LDU 256 ENDS }
PUSHCONT { PUSHINT 0 }
IFELSE
;; return
RET

.globl	get_msg_sender
.type	get_msg_sender, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: get_msg_sender
;; get member msgSender
;; Index of TvmTempData.msgSender
PUSHINT 1
;; tvm_get_tmp_dictionary
PUSH c7
SECOND
CTOS
PLDDICT
PUSHINT 8
DICTUGET
PUSHCONT { LDU 256 ENDS }
PUSHCONT { PUSHINT 0 }
IFELSE
;; return
RET

.globl	get_msg_balance
.type	get_msg_balance, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: get_msg_balance
;; get member msgBalance
;; Index of TvmTempData.msgBalance
PUSHINT 2
;; tvm_get_tmp_dictionary
PUSH c7
SECOND
CTOS
PLDDICT
PUSHINT 8
DICTUGET
PUSHCONT { LDU 256 ENDS }
PUSHCONT { PUSHINT 0 }
IFELSE
;; return
RET

.globl	encode_array
.type	encode_array, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: encode_array
;; param: builder
;; param: array
;; param: 
PRINTSTR encode_array
PUSHINT 1
;; builder
;; stack=4
PUSH s3
STU 2
POP s3
;; array
;; stack=3
PUSH s1
PUSHINT 32
DICTUMAX
PUSHCONT { POP s1 INC }
PUSHCONT { PUSHINT 0 }
IFELSE
;; decl: len
;; len
;; stack=4
DUP
;; builder
;; stack=5
PUSH s4
STU 32
POP s4
;; array
;; stack=4
PUSH s2
;; builder
;; stack=5
PUSH s4
STDICT
;; assign builder
POP s4
;; builder
;; stack=4
PUSH s3
;; return
XCHG s4
BLKDROP 4
RET

.globl	decode_array
.type	decode_array, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: decode_array
;; param: slice
;; param: 
PRINTSTR decode_array
;; if
;; slice
;; stack=2
PUSH s1
SDEMPTY
PUSHCONT {
	;; slice
	;; stack=2
	PUSH s1
	LDREF
	POP s3
	;; decl: refcell
	;; refcell
	;; stack=3
	DUP
	CTOS
	;; assign slice
	POP s3
	;; drop locals
	DROP
}
IF
;; slice
;; stack=2
PUSH s1
LDU 2
POP s3
;; decl: dec_alg
;; dec_alg
;; stack=3
DUP
PUSHINT 1
;; ==
EQUAL
THROWIFNOT 100
;; slice
;; stack=3
PUSH s2
LDU 32
POP s4
;; decl: len
;; slice
;; stack=4
PUSH s3
LDDICT
;; decl: array
;; decl: restSlice
;; array
;; stack=6
PUSH s1
PUSHINT 32
DICTUMAX
PUSHCONT { POP s1 INC }
PUSHCONT { PUSHINT 0 }
IFELSE
;; decl: len_actual
;; len
;; stack=7
PUSH s3
;; len_actual
;; stack=8
PUSH s1
;; ==
EQUAL
THROWIFNOT 100
PRINTSTR decode_array_ok
;; array
;; stack=7
PUSH s2
;; restSlice
;; stack=8
PUSH s2
;; return
BLKSWAP 7, 2
BLKDROP 7
RET

.globl	load_slice_from_two_cell
.type	load_slice_from_two_cell, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: load_slice_from_two_cell
;; param: slice
;; param: bitQty0
;; param: bitQty1
;; slice
;; stack=3
PUSH s2
;; bitQty0
;; stack=4
PUSH s2
LDSLICEX
POP s4
;; decl: sliceValue0
;; slice
;; stack=4
PUSH s3
LDREF
POP s5
;; decl: nextCell
;; slice
;; stack=5
PUSH s4
ENDS
NULL
POP s5
;; nextCell
;; stack=5
DUP
CTOS
;; assign slice
POP s5
;; slice
;; stack=5
PUSH s4
;; bitQty1
;; stack=6
PUSH s3
LDSLICEX
POP s6
;; decl: sliceValue1
NEWC
;; decl: numberBuilder
;; sliceValue0
;; stack=7
PUSH s3
;; numberBuilder
;; stack=8
PUSH s1
STSLICE
NIP
;; sliceValue1
;; stack=7
PUSH s1
;; numberBuilder
;; stack=8
PUSH s1
STSLICE
NIP
;; numberBuilder
;; stack=7
DUP
ENDC
CTOS
;; slice
;; stack=8
PUSH s7
;; return
BLKSWAP 7, 2
BLKDROP 7
RET

.globl	abi_encode_packed
.type	abi_encode_packed, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: abi_encode_packed
;; param: builder
;; param: array
;; param: bitSizeOfArrayElement
;; array
;; stack=3
PUSH s1
PUSHINT 32
DICTUMAX
PUSHCONT { POP s1 INC }
PUSHCONT { PUSHINT 0 }
IFELSE
;; decl: arraySize
; for statement
PUSHINT 0
;; decl: idx
PUSHCONT {
	;; idx
	;; stack=5
	DUP
	;; arraySize
	;; stack=6
	PUSH s2
	;; <
	LESS
	NOT DUP IFRET DROP
	;; m_isUntil = 1
	;; bitSizeOfArrayElement
	;; stack=5
	PUSH s2
	;; idx
	;; stack=6
	PUSH s1
	;; array
	;; stack=7
	PUSH s5
	PUSHINT 32
	DICTUGET
	PUSHCONT { 
		NIP
	}
	PUSHCONT {
		NEWC      ; valueBits builder
		PUSHINT 0 ; valueBits builder 0
		XCHG S2   ; 0 builder valueBits
		STUX      ; builder
		ENDC      ; cell
		CTOS      ; default_value
	}
	IFELSE
	;; decl: data_slice
	;; data_slice
	;; stack=6
	DUP
	;; builder
	;; stack=7
	PUSH s6
	STSLICE
	POP s6
	;; drop locals
	DROP
	;; ++
	INC
	FALSE
}
UNTIL
; erase idx
DROP
; for end
;; builder
;; stack=4
PUSH s3
;; return
XCHG s4
BLKDROP 4
RET

.globl	smart_ldi
.type	smart_ldi, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: smart_ldi
;; param: slice
;; param: bits
;; slice
;; stack=2
PUSH s1
SBITS ; tvm_sbits
;; decl: remBits
;; if
;; remBits
;; stack=3
DUP
;; bits
;; stack=4
PUSH s2
;; >=
GEQ
PUSHCONT {
	;; slice
	;; stack=3
	PUSH s2
	;; bits
	;; stack=4
	PUSH s2
	LDIX
	POP s4
	;; decl: number
	;; number
	;; stack=4
	DUP
	;; slice
	;; stack=5
	PUSH s4
	;; return
	BLKSWAP 4, 2
	BLKDROP 4
	RET
}
IFJMP
;; slice
;; stack=3
PUSH s2
;; remBits
;; stack=4
PUSH s1
LDSLICEX
POP s4
;; decl: sliceVal0
;; slice
;; stack=4
PUSH s3
LDREF
POP s5
;; decl: newCell
;; slice
;; stack=5
PUSH s4
ENDS
NULL
POP s5
;; newCell
;; stack=5
DUP
CTOS
;; decl: newSlice
;; newSlice
;; stack=6
DUP
;; bits
;; stack=7
PUSH s5
;; remBits
;; stack=8
PUSH s5
;; -
SUB
LDSLICEX
POP s2
;; decl: sliceVal1
NEWC
;; decl: numberBuilderOrSlice
;; sliceVal0
;; stack=8
PUSH s4
;; numberBuilderOrSlice
;; stack=9
PUSH s1
STSLICE
NIP
;; sliceVal1
;; stack=8
PUSH s1
;; numberBuilderOrSlice
;; stack=9
PUSH s1
STSLICE
NIP
;; numberBuilderOrSlice
;; stack=8
DUP
ENDC
CTOS
;; assign numberBuilderOrSlice
NIP
;; numberBuilderOrSlice
;; stack=8
DUP
;; bits
;; stack=9
PUSH s7
LDIX
POP s2
;; decl: number
;; number
;; stack=9
DUP
;; newSlice
;; stack=10
PUSH s4
;; return
BLKSWAP 9, 2
BLKDROP 9
RET

.globl	smart_ldu
.type	smart_ldu, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: smart_ldu
;; param: slice
;; param: bits
;; slice
;; stack=2
PUSH s1
SBITS ; tvm_sbits
;; decl: remBits
;; if
;; remBits
;; stack=3
DUP
;; bits
;; stack=4
PUSH s2
;; >=
GEQ
PUSHCONT {
	;; slice
	;; stack=3
	PUSH s2
	;; bits
	;; stack=4
	PUSH s2
	LDUX
	POP s4
	;; decl: number
	;; number
	;; stack=4
	DUP
	;; slice
	;; stack=5
	PUSH s4
	;; return
	BLKSWAP 4, 2
	BLKDROP 4
	RET
}
IFJMP
;; slice
;; stack=3
PUSH s2
;; remBits
;; stack=4
PUSH s1
LDSLICEX
POP s4
;; decl: sliceVal0
;; slice
;; stack=4
PUSH s3
LDREF
POP s5
;; decl: newCell
;; slice
;; stack=5
PUSH s4
ENDS
NULL
POP s5
;; newCell
;; stack=5
DUP
CTOS
;; decl: newSlice
;; newSlice
;; stack=6
DUP
;; bits
;; stack=7
PUSH s5
;; remBits
;; stack=8
PUSH s5
;; -
SUB
LDSLICEX
POP s2
;; decl: sliceVal1
NEWC
;; decl: numberBuilderOrSlice
;; sliceVal0
;; stack=8
PUSH s4
;; numberBuilderOrSlice
;; stack=9
PUSH s1
STSLICE
NIP
;; sliceVal1
;; stack=8
PUSH s1
;; numberBuilderOrSlice
;; stack=9
PUSH s1
STSLICE
NIP
;; numberBuilderOrSlice
;; stack=8
DUP
ENDC
CTOS
;; assign numberBuilderOrSlice
NIP
;; numberBuilderOrSlice
;; stack=8
DUP
;; bits
;; stack=9
PUSH s7
LDUX
POP s2
;; decl: number
;; number
;; stack=9
DUP
;; newSlice
;; stack=10
PUSH s4
;; return
BLKSWAP 9, 2
BLKDROP 9
RET

.globl	send_int_msg
.type	send_int_msg, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: send_int_msg
;; param: 
;; param: body_slice
;; param: dst_account
;; param: grams_value
PRINTSTR send_int_msg
NEWC
;; decl: builder
PUSHINT 2
;; builder
;; stack=6
PUSH s1
STU 2
NIP
PUSHINT 0
;; builder
;; stack=6
PUSH s1
STU 1
NIP
PUSHINT 0
;; builder
;; stack=6
PUSH s1
STU 8
NIP
;; dst_account
;; stack=5
PUSH s2
;; builder
;; stack=6
PUSH s1
STU 256
NIP
;; builder
;; stack=5
DUP
ENDC
CTOS
;; assign builder
NIP
PUSHINT $get_snd_addr_slice$
CALL 1
;; decl: snd_addr
NOW
;; decl: unixtime
;; body_slice
;; stack=7
PUSH s5
;; unixtime
;; stack=8
PUSH s1
PUSHINT 0
PUSHINT 0
PUSHINT 0
;; grams_value
;; stack=12
PUSH s8
;; builder
;; stack=13
PUSH s8
;; snd_addr
;; stack=14
PUSH s8
PUSHINT 1
PUSHINT 0
PUSHINT $build_internal_outbound_message$
CALL 1
;; decl: cell
;; cell
;; stack=8
DUP
PUSHINT 0
SENDRAWMSG
BLKDROP 8

.globl	build_internal_outbound_message
.type	build_internal_outbound_message, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: build_internal_outbound_message
;; param: body_slice
;; param: unixtime
;; param: logical_time
;; param: fwd_fee
;; param: ihr_fee
;; param: value
;; param: dst_addr_slice
;; param: src_addr_slice
;; param: bounce
;; param: ihr_disabled
PRINTSTR buildmsg
NEWC
;; decl: builder
PUSHINT 0
;; builder
;; stack=12
PUSH s1
STU 1
NIP
;; ihr_disabled
;; stack=11
PUSH s1
;; builder
;; stack=12
PUSH s1
STU 1
NIP
;; bounce
;; stack=11
PUSH s2
;; builder
;; stack=12
PUSH s1
STU 1
NIP
PUSHINT 0
;; builder
;; stack=12
PUSH s1
STU 1
NIP
;; src_addr_slice
;; stack=11
PUSH s3
;; builder
;; stack=12
PUSH s1
STSLICE
NIP
;; dst_addr_slice
;; stack=11
PUSH s4
;; builder
;; stack=12
PUSH s1
STSLICE
NIP
;; builder
;; stack=11
DUP
;; value
;; stack=12
PUSH s6
PUSHINT $encode_grams$
CALL 1
;; assign builder
NIP
PUSHINT 0
;; builder
;; stack=12
PUSH s1
STU 1
NIP
;; builder
;; stack=11
DUP
;; ihr_fee
;; stack=12
PUSH s7
PUSHINT $encode_grams$
CALL 1
;; assign builder
NIP
;; builder
;; stack=11
DUP
;; fwd_fee
;; stack=12
PUSH s8
PUSHINT $encode_grams$
CALL 1
;; assign builder
NIP
;; logical_time
;; stack=11
PUSH s8
;; builder
;; stack=12
PUSH s1
STU 64
NIP
;; unixtime
;; stack=11
PUSH s9
;; builder
;; stack=12
PUSH s1
STU 32
NIP
PUSHINT 0
;; builder
;; stack=12
PUSH s1
STU 1
NIP
;; builder
;; stack=11
DUP
BREMBITS ; tvm_brembits
;; decl: bits
;; body_slice
;; stack=12
PUSH s11
SBITS ; tvm_sbits
PUSHINT 1
;; +
ADD
;; decl: body_bits
;; if
;; bits
;; stack=13
PUSH s1
;; body_bits
;; stack=14
PUSH s1
;; >
GREATER
PUSHCONT {
	PUSHINT 0
	;; builder
	;; stack=14
	PUSH s3
	STU 1
	POP s3
	;; body_slice
	;; stack=13
	PUSH s12
	;; builder
	;; stack=14
	PUSH s3
	STSLICE
	POP s3
}
PUSHCONT {
	PUSHINT 1
	;; builder
	;; stack=14
	PUSH s3
	STU 1
	POP s3
	NEWC
	;; decl: builder2
	;; body_slice
	;; stack=14
	PUSH s13
	;; builder2
	;; stack=15
	PUSH s1
	STSLICE
	NIP
	;; builder2
	;; stack=14
	DUP
	ENDC
	;; builder
	;; stack=15
	PUSH s4
	STREF
	POP s4
	;; drop locals
	DROP
}
IFELSE
;; builder
;; stack=13
PUSH s2
ENDC
;; return
XCHG s13
BLKDROP 13
RET

.globl	encode_grams
.type	encode_grams, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: encode_grams
;; param: builder
;; param: value
PRINTSTR encodegrams
;; if
;; value
;; stack=2
DUP
PUSHINT 0
;; !=
NEQ
PUSHCONT {
	;; value
	;; stack=2
	DUP
	UBITSIZE
	PUSHINT 7
	;; +
	ADD
	PUSHINT 8
	;; /
	DIV
	;; decl: byteLen
	;; byteLen
	;; stack=3
	DUP
	;; builder
	;; stack=4
	PUSH s3
	STU 4
	POP s3
	;; value
	;; stack=3
	PUSH s1
	;; builder
	;; stack=4
	PUSH s3
	;; byteLen
	;; stack=5
	PUSH s2
	PUSHINT 8
	;; *
	MUL
	STUX
	POP s3
	;; drop locals
	DROP
}
PUSHCONT {
	PUSHINT 0
	;; builder
	;; stack=3
	PUSH s2
	STU 4
	POP s2
}
IFELSE
;; builder
;; stack=2
PUSH s1
;; return
POP s1
POP s1
RET

.globl	put_in_dictionary_as_slice
.type	put_in_dictionary_as_slice, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: put_in_dictionary_as_slice
;; param: data
;; param: key
;; param: dictionary
;; param: bits
;; param: dataSize
NEWC
;; decl: builder
;; data
;; stack=6
PUSH s5
;; builder
;; stack=7
PUSH s1
;; dataSize
;; stack=8
PUSH s3
STUX
NIP
;; builder
;; stack=6
DUP
ENDC
CTOS
;; assign builder
NIP
;; builder
;; stack=6
DUP
;; key
;; stack=7
PUSH s5
;; dictionary
;; stack=8
PUSH s5
;; bits
;; stack=9
PUSH s5
DICTUSET
POP s4
;; dictionary
;; stack=6
PUSH s3
;; return
XCHG s6
BLKDROP 6
RET

.globl	store_signature
.type	store_signature, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: store_signature
;; param: gram_balance
;; param: msg_balance
;; param: src_addr
;; param: sign
PRINTSTR store_signature
NEWDICT
;; decl: dict
;; sign
;; stack=5
PUSH s1
PUSHINT 0
;; dict
;; stack=7
PUSH s2
PUSHINT 8
PUSHINT 256
PUSHINT $put_in_dictionary_as_slice$
CALL 1
;; assign dict
NIP
;; src_addr
;; stack=5
PUSH s2
PUSHINT 1
;; dict
;; stack=7
PUSH s2
PUSHINT 8
PUSHINT 256
PUSHINT $put_in_dictionary_as_slice$
CALL 1
;; assign dict
NIP
;; msg_balance
;; stack=5
PUSH s3
PUSHINT 2
;; dict
;; stack=7
PUSH s2
PUSHINT 8
PUSHINT 256
PUSHINT $put_in_dictionary_as_slice$
CALL 1
;; assign dict
NIP
;; gram_balance
;; stack=5
PUSH s4
PUSHINT 3
;; dict
;; stack=7
PUSH s2
PUSHINT 8
PUSHINT 256
PUSHINT $put_in_dictionary_as_slice$
CALL 1
;; assign dict
NIP
PUSHINT $get_rand_seed$
CALL 1
;; decl: rand_seed
PUSHINT $get_contract_balance$
CALL 1
;; decl: nanograms
NEWC
;; decl: balance
;; nanograms
;; stack=8
PUSH s1
;; balance
;; stack=9
PUSH s1
STU 128
NIP
;; balance
;; stack=8
DUP
ENDC
CTOS
;; assign balance
NIP
PUSHINT $get_self_address$
CALL 1
;; decl: msgaddress
;; msgaddress
;; stack=9
DUP
PUSHINT 4
;; dict
;; stack=11
PUSH s6
PUSHINT 8
PUSHINT 256
PUSHINT $put_in_dictionary_as_slice$
CALL 1
;; assign dict
POP s5
;; balance
;; stack=9
PUSH s1
PUSHINT 5
;; dict
;; stack=11
PUSH s6
PUSHINT 8
DICTUSET
POP s5
;; rand_seed
;; stack=9
PUSH s3
PUSHINT 6
;; dict
;; stack=11
PUSH s6
PUSHINT 8
PUSHINT 256
PUSHINT $put_in_dictionary_as_slice$
CALL 1
;; assign dict
POP s5
NEWC
;; decl: builder
;; dict
;; stack=10
PUSH s5
;; builder
;; stack=11
PUSH s1
STDICT
;; assign builder
NIP
;; builder
;; stack=10
DUP
ENDC
;; assign builder
NIP
PUSHCTR c7
;; decl: c7
;; c7
;; stack=11
DUP
;; builder
;; stack=12
PUSH s2
TPUSH
;; assign c7
NIP
;; c7
;; stack=11
DUP
POPCTR c7
BLKDROP 11

.globl	build_external_outbound_message
.type	build_external_outbound_message, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: build_external_outbound_message
;; param: body
;; param: logical_time
;; param: src_address
PRINTSTR build_ext_msg
NEWC
;; decl: builder
PUSHINT 3
;; builder
;; stack=5
PUSH s1
STU 2
NIP
;; src_address
;; stack=4
PUSH s1
;; builder
;; stack=5
PUSH s1
STSLICE
NIP
PUSHINT 0
;; builder
;; stack=5
PUSH s1
STU 2
NIP
;; logical_time
;; stack=4
PUSH s2
;; builder
;; stack=5
PUSH s1
STU 64
NIP
PUSHINT 0
;; builder
;; stack=5
PUSH s1
STU 32
NIP
PUSHINT 0
;; builder
;; stack=5
PUSH s1
STU 1
NIP
;; builder
;; stack=4
DUP
BREMBITS ; tvm_brembits
;; decl: bits
;; body
;; stack=5
PUSH s4
SBITS ; tvm_sbits
PUSHINT 1
;; +
ADD
;; decl: body_bits
;; if
;; bits
;; stack=6
PUSH s1
;; body_bits
;; stack=7
PUSH s1
;; >
GREATER
PUSHCONT {
	PUSHINT 0
	;; builder
	;; stack=7
	PUSH s3
	STU 1
	POP s3
	;; body
	;; stack=6
	PUSH s5
	;; builder
	;; stack=7
	PUSH s3
	STSLICE
	POP s3
}
PUSHCONT {
	PUSHINT 1
	;; builder
	;; stack=7
	PUSH s3
	STU 1
	POP s3
	NEWC
	;; decl: builder2
	;; body
	;; stack=7
	PUSH s6
	;; builder2
	;; stack=8
	PUSH s1
	STSLICE
	NIP
	;; builder2
	;; stack=7
	DUP
	ENDC
	;; builder
	;; stack=8
	PUSH s4
	STREF
	POP s4
	;; drop locals
	DROP
}
IFELSE
;; builder
;; stack=6
PUSH s2
ENDC
;; return
XCHG s6
BLKDROP 6
RET

.globl	change_array_length
.type	change_array_length, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: change_array_length
;; param: slice
;; param: array
;; param: new_len
PRINTSTR change_arr_len
;; array
;; stack=3
PUSH s1
PUSHINT 32
DICTUMAX
PUSHCONT { POP s1 INC }
PUSHCONT { PUSHINT 0 }
IFELSE
;; decl: len
;; if
;; len
;; stack=4
DUP
;; new_len
;; stack=5
PUSH s2
;; >=
GEQ
PUSHCONT {
	; while statement
	PUSHCONT {
		;; len
		;; stack=4
		DUP
		;; new_len
		;; stack=5
		PUSH s2
		;; >
		GREATER
		NOT DUP IFRET DROP
		;; m_isUntil = 1
		;; --
		DEC
		;; len
		;; stack=4
		DUP
		;; array
		;; stack=5
		PUSH s3
		PUSHINT 32
		DICTUDEL
		DROP
		;; assign array
		POP s3
		FALSE
	}
	UNTIL
	; while end
}
PUSHCONT {
	;; if
	;; !
	;; slice
	;; stack=4
	PUSH s3
	ISNULL
	NOT
	PUSHCONT {
		;; slice
		;; stack=4
		PUSH s3
		;; new_len
		;; stack=5
		PUSH s2
		PUSHINT 1
		;; -
		SUB
		;; array
		;; stack=6
		PUSH s4
		PUSHINT 32
		DICTUSET
		POP s3
	}
	IF
}
IFELSE
;; array
;; stack=4
PUSH s2
;; return
XCHG s4
BLKDROP 4
RET

.globl	send_grams
.type	send_grams, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: send_grams
;; param: grams_value
;; param: dst_addr
;; param: body_slice
PRINTSTR send_grams
PUSHINT 0
;; body_slice
;; stack=4
PUSH s1
;; dst_addr
;; stack=5
PUSH s3
;; grams_value
;; stack=6
PUSH s5
PUSHINT $send_int_msg$
CALL 1
BLKDROP 3

.globl	send_int_msg_2
.type	send_int_msg_2, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: send_int_msg_2
;; param: dst_addr
;; param: body_slice
PRINTSTR send_int_msg_2
PUSHINT 0
;; body_slice
;; stack=3
PUSH s1
;; dst_addr
;; stack=4
PUSH s3
PUSHINT 10000
PUSHINT $send_int_msg$
CALL 1
BLKDROP 2

.globl	send_ext_msg
.type	send_ext_msg, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: send_ext_msg
;; param: body_slice
PRINTSTR send_ext_msg
LTIME
;; decl: ltime
PUSHINT $get_snd_addr_slice$
CALL 1
;; decl: snd_addr
;; body_slice
;; stack=3
PUSH s2
;; ltime
;; stack=4
PUSH s2
;; snd_addr
;; stack=5
PUSH s2
PUSHINT $build_external_outbound_message$
CALL 1
;; decl: cell
;; cell
;; stack=4
DUP
PUSHINT 0
SENDRAWMSG
BLKDROP 4

.globl	get_self_address
.type	get_self_address, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: get_self_address
PRINTSTR get_self_addr
PUSHINT $get_snd_addr_slice$
CALL 1
PUSHINT 11
PUSHINT $get_address_from_slice$
CALL 1
;; return
RET

.globl	get_snd_addr_slice
.type	get_snd_addr_slice, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: get_snd_addr_slice
PUSHCTR c7
FIRST
INDEX 8
;; return
RET

.globl	get_address_from_slice
.type	get_address_from_slice, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: get_address_from_slice
;; param: slice
;; param: offset
;; slice
;; stack=2
PUSH s1
;; offset
;; stack=3
PUSH s1
SDSKIPFIRST
;; decl: result
;; result
;; stack=3
DUP
LDU 256
POP s2
;; assign result
NIP
;; result
;; stack=3
DUP
;; return
XCHG s3
BLKDROP 3
RET

.globl	get_rand_seed
.type	get_rand_seed, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: get_rand_seed
PRINTSTR get_rand_seed
PUSHCTR c7
FIRST
INDEX 6
;; return
RET

.globl	get_contract_balance
.type	get_contract_balance, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: get_contract_balance
PRINTSTR get_balance
PUSHCTR c7
FIRST
INDEX 7
FIRST
;; return
RET

.globl	get_src_addr_and_bounce
.type	get_src_addr_and_bounce, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: get_src_addr_and_bounce
;; param: msg_cell
PRINTSTR get_src_addr
;; msg_cell
;; stack=1
DUP
CTOS
;; decl: msg_slice
;; msg_slice
;; stack=2
DUP
LDU 1
POP s2
;; decl: msg_info
;; if
;; msg_info
;; stack=3
DUP
PUSHINT 0
;; !=
NEQ
PUSHCONT {
	PUSHINT 0
	PUSHINT 0
	PUSHINT 0
	;; return
	BLKSWAP 3, 3
	BLKDROP 3
	RET
}
IFJMP
;; msg_slice
;; stack=3
PUSH s1
PUSHINT 1
SDSKIPFIRST
;; assign msg_slice
POP s2
;; msg_slice
;; stack=3
PUSH s1
LDU 1
POP s3
;; decl: bounce
;; msg_slice
;; stack=4
PUSH s2
LDU 1
POP s4
;; decl: bounced
;; msg_slice
;; stack=5
PUSH s3
PUSHINT 11
PUSHINT $get_address_from_slice$
CALL 1
;; decl: addr
;; bounce
;; stack=6
PUSH s2
;; bounced
;; stack=7
PUSH s2
;; addr
;; stack=8
PUSH s2
;; return
BLKSWAP 6, 3
BLKDROP 6
RET

.globl	get_msg_pubkey
.type	get_msg_pubkey, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: get_msg_pubkey
;; param: msg_slice
PRINTSTR get_msg_pubkey
PUSHINT 0
;; decl: pubKey
;; if
;; msg_slice
;; stack=2
PUSH s1
SREMPTY
PUSHCONT {
	;; m_addReturnFlag = 1
	PUSHINT 0
	;; return
	POP s1
	POP s1
	PUSHINT 1 ; return
	RET
}
PUSHCONT {
	;; m_addReturnFlag = 1
	;; msg_slice
	;; stack=2
	PUSH s1
	LDREFRTOS
	;; decl: rest_msg_slice
	;; decl: slice
	;; if
	;; slice
	;; stack=4
	DUP
	SDEMPTY
	PUSHCONT {
		;; m_addReturnFlag = 1
		PUSHINT 0
		;; return
		XCHG s4
		BLKDROP 4
		PUSHINT 1 ; return
		RET
	}
	IFJMP
	;; slice
	;; stack=4
	DUP
	PUSHINT 512
	PUSHINT $get_address_from_slice$
	CALL 1
	;; assign pubKey
	POP s3
	;; rest_msg_slice
	;; stack=4
	PUSH s1
	HASHSU
	;; decl: hash
	;; hash
	;; stack=5
	DUP
	;; slice
	;; stack=6
	PUSH s2
	;; pubKey
	;; stack=7
	PUSH s5
	CHKSIGNU
	;; decl: checkSig
	;; checkSig
	;; stack=6
	DUP
	THROWIFNOT 40
	;; drop locals
	BLKDROP 4
	FALSE
}
IFELSE
IFRET
;; pubKey
;; stack=2
DUP
;; return
POP s1
POP s1
RET

.globl	main_internal_body
.type	main_internal_body, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: main_internal_body
;; param: contract_balance
;; param: msg_balance
;; param: msg_cell
;; param: msg_body_slice
PRINTSTR main_internal
;; msg_cell
;; stack=4
PUSH s1
PUSHINT $get_src_addr_and_bounce$
CALL 1
;; decl: bounce
;; decl: bounced
;; decl: src_addr
;; contract_balance
;; stack=7
PUSH s6
;; msg_balance
;; stack=8
PUSH s6
;; src_addr
;; stack=9
PUSH s2
PUSHINT 0
PUSHINT $store_signature$
CALL 1
;; if
;; msg_body_slice
;; stack=7
PUSH s3
SEMPTY
PUSHCONT {
	;; if
	;; bounced
	;; stack=7
	PUSH s1
	PUSHINT 0
	;; ==
	EQUAL
	PUSHCONT {
		PUSHINT $fallback$
		;; decl: id_fun
		PUSHINT 0
		;; id_fun
		;; stack=9
		PUSH s1
		PUSHINT 0
		;; return
		BLKSWAP 8, 3
		BLKDROP 8
		RET
	}
	IFJMP
	PUSHINT 0
	PUSHINT 0
	PUSHINT 1
	;; return
	BLKSWAP 7, 3
	BLKDROP 7
	RET
}
IFJMP
;; msg_body_slice
;; stack=7
PUSH s3
PUSHINT $parse_abi_and_load_func_id$
CALL 1
;; decl: rest_body_slice
;; decl: func_id
;; rest_body_slice
;; stack=9
PUSH s1
;; func_id
;; stack=10
PUSH s1
PUSHINT 0
;; return
BLKSWAP 9, 3
BLKDROP 9
RET

.globl	main_external_body
.type	main_external_body, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: main_external_body
;; param: contract_balance
;; param: msg_balance
;; param: msg_cell
;; param: msg_body_slice
PRINTSTR main_external
;; msg_cell
;; stack=4
PUSH s1
PUSHINT $get_src_addr_and_bounce$
CALL 1
;; decl: bounce
;; decl: bounced
;; decl: src_addr
;; msg_body_slice
;; stack=7
PUSH s3
PUSHINT $get_msg_pubkey$
CALL 1
;; decl: pubKey
;; if
;; !
;; msg_body_slice
;; stack=8
PUSH s4
SREMPTY
NOT
PUSHCONT {
	;; msg_body_slice
	;; stack=8
	PUSH s4
	LDREF
	NIP
	;; assign msg_body_slice
	POP s5
}
IF
;; contract_balance
;; stack=8
PUSH s7
;; msg_balance
;; stack=9
PUSH s7
;; src_addr
;; stack=10
PUSH s3
;; pubKey
;; stack=11
PUSH s3
PUSHINT $store_signature$
CALL 1
;; if
;; msg_body_slice
;; stack=8
PUSH s4
SDEMPTY
PUSHCONT {
	PRINTSTR msg_is_empty
	NEWDICT
	;; decl: dict
	NEWC
	;; decl: builder
	;; dict
	;; stack=10
	PUSH s1
	;; builder
	;; stack=11
	PUSH s1
	STDICT
	ENDC
	;; assign builder
	NIP
	;; builder
	;; stack=10
	DUP
	POPCTR c4
	PUSHINT 0
	PUSHINT 0
	PUSHINT 1
	;; return
	BLKSWAP 10, 3
	BLKDROP 10
	RET
}
IFJMP
;; msg_body_slice
;; stack=8
PUSH s4
PUSHINT $parse_abi_and_load_func_id$
CALL 1
;; decl: rest_body_slice
;; decl: func_id
;; rest_body_slice
;; stack=10
PUSH s1
;; func_id
;; stack=11
PUSH s1
PUSHINT 0
;; return
BLKSWAP 10, 3
BLKDROP 10
RET

.globl	parse_abi_and_load_func_id
.type	parse_abi_and_load_func_id, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: parse_abi_and_load_func_id
;; param: msg_body_slice
;; msg_body_slice
;; stack=1
DUP
LDU 8
POP s2
;; decl: abi_version
;; abi_version
;; stack=2
DUP
PUSHINT 0
;; ==
EQUAL
THROWIFNOT 55
;; msg_body_slice
;; stack=2
PUSH s1
LDU 32
POP s3
;; decl: func_id
;; msg_body_slice
;; stack=3
PUSH s2
;; func_id
;; stack=4
PUSH s1
;; return
BLKSWAP 3, 2
BLKDROP 3
RET

